---
phase: 02-master-data-warehouses
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/product.py
  - app/models/stock.py
  - app/models/defect_stock.py
  - app/models/__init__.py
  - app/schemas/product.py
  - alembic/versions/002_products_stocks.py
autonomous: true

must_haves:
  truths:
    - "Product model exists with barcode, gtin, seller_sku, size, brand, color fields"
    - "Barcode and GTIN have unique constraints in database"
    - "Product supports soft delete (is_deleted field)"
    - "Stock model links to Product with quantity field"
    - "DefectStock model links to Product with quantity field"
    - "Migration creates products, stocks, defect_stocks tables"
  artifacts:
    - path: "app/models/product.py"
      provides: "Product SQLAlchemy model with soft delete"
      contains: "is_deleted"
      min_lines: 30
    - path: "app/models/stock.py"
      provides: "Stock model linked to product"
      contains: "ForeignKey"
      min_lines: 20
    - path: "app/models/defect_stock.py"
      provides: "DefectStock model linked to product"
      contains: "ForeignKey"
      min_lines: 20
    - path: "alembic/versions/002_products_stocks.py"
      provides: "Migration for new tables"
      exports: ["upgrade", "downgrade"]
  key_links:
    - from: "app/models/stock.py"
      to: "app/models/product.py"
      via: "ForeignKey('products.id')"
      pattern: "ForeignKey.*products"
    - from: "app/models/defect_stock.py"
      to: "app/models/product.py"
      via: "ForeignKey('products.id')"
      pattern: "ForeignKey.*products"
---

<objective>
Create SQLAlchemy models for Product, Stock, and DefectStock with proper relationships and soft delete support. Add Pydantic schemas for API serialization. Create Alembic migration for database tables.

Purpose: Establish data layer for master data management with automatic stock record creation support.
Output: Working models, schemas, and migration ready for API layer.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Existing Patterns (follow these)

### Model Pattern (from app/models/source.py):
```python
from sqlalchemy import String, Text
from sqlalchemy.orm import Mapped, mapped_column
from typing import Optional

from app.models.base import Base, UUIDMixin, TimestampMixin

class Source(Base, UUIDMixin, TimestampMixin):
    __tablename__ = "sources"
    
    name: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
```

### Schema Pattern (from app/schemas/source.py):
```python
from pydantic import BaseModel
from datetime import datetime
from uuid import UUID
from typing import Optional

class SourceBase(BaseModel):
    name: str
    description: Optional[str] = None

class SourceCreate(SourceBase):
    pass

class SourceUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None

class SourceResponse(SourceBase):
    id: UUID
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
```

### Base Mixins (app/models/base.py):
- Base: DeclarativeBase
- UUIDMixin: UUID primary key with uuid4 default
- TimestampMixin: created_at, updated_at with auto-update

## Phase 2 Requirements

- PROD-01: Product fields: barcode, gtin, seller_sku, size, brand, color
- PROD-02: Barcode unique
- PROD-03: GTIN unique
- PROD-05: Soft delete (is_deleted flag)
- PROD-08: Stock quantity in product list
- STOCK-01: Stock auto-created with quantity=0
- STOCK-02: DefectStock auto-created with quantity=0
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Product, Stock, DefectStock models</name>
  <files>
    app/models/product.py
    app/models/stock.py
    app/models/defect_stock.py
    app/models/__init__.py
  </files>
  <action>
Create three SQLAlchemy models following the established pattern:

**1. Product model (app/models/product.py):**
- Fields: id (UUID via UUIDMixin), barcode (String 100, unique, indexed), gtin (String 14, unique, indexed), seller_sku (String 100, nullable), size (String 50, nullable), brand (String 255, nullable), color (String 100, nullable), is_deleted (Boolean, default=False, indexed), created_at, updated_at (via TimestampMixin)
- Table name: "products"
- Use Mapped[] type hints with mapped_column
- Import from app.models.base: Base, UUIDMixin, TimestampMixin

**2. Stock model (app/models/stock.py):**
- Fields: id (UUID), product_id (UUID, ForeignKey to products.id, unique constraint), quantity (Integer, default=0, nullable=False), created_at, updated_at
- Table name: "stocks"
- relationship: product = relationship("Product", back_populates="stock")
- ONE-TO-ONE: Each product has exactly one Stock record

**3. DefectStock model (app/models/defect_stock.py):**
- Fields: id (UUID), product_id (UUID, ForeignKey to products.id, unique constraint), quantity (Integer, default=0, nullable=False), created_at, updated_at
- Table name: "defect_stocks"
- relationship: product = relationship("Product", back_populates="defect_stock")
- ONE-TO-ONE: Each product has exactly one DefectStock record

**4. Update app/models/__init__.py:**
- Export Product, Stock, DefectStock
- Add relationships on Product model: stock and defect_stock back-references

IMPORTANT: Do NOT add service layer yet - that comes with API. Just models.
  </action>
  <verify>
grep -l "class Product" app/models/product.py && \
grep -l "class Stock" app/models/stock.py && \
grep -l "class DefectStock" app/models/defect_stock.py && \
grep -E "Product|Stock|DefectStock" app/models/__init__.py
  </verify>
  <done>
Product, Stock, DefectStock models exist with proper relationships, unique constraints on barcode/GTIN, and soft delete support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Product Pydantic schemas</name>
  <files>app/schemas/product.py</files>
  <action>
Create Pydantic schemas for Product API following established patterns:

**ProductBase:**
- barcode: str
- gtin: str
- seller_sku: Optional[str] = None
- size: Optional[str] = None
- brand: Optional[str] = None
- color: Optional[str] = None

**ProductCreate(ProductBase):**
- Inherits all fields from ProductBase

**ProductUpdate(BaseModel):**
- All fields Optional for partial updates
- barcode: Optional[str] = None
- gtin: Optional[str] = None
- seller_sku, size, brand, color: all Optional[str] = None

**ProductResponse(ProductBase):**
- id: UUID
- created_at: datetime
- updated_at: datetime
- Config: from_attributes = True

**ProductWithStockResponse(ProductResponse):**
- stock_quantity: int (from related Stock)
- defect_quantity: int (from related DefectStock)
- Used for list endpoint with stock info

**ProductListResponse(BaseModel):**
- items: list[ProductWithStockResponse]
- total: int
- page: int
- page_size: int
- pages: int (total pages)
  </action>
  <verify>
grep -l "ProductCreate\|ProductResponse\|ProductWithStockResponse" app/schemas/product.py && \
grep -E "stock_quantity|defect_quantity" app/schemas/product.py
  </verify>
  <done>
All product schemas exist including ProductWithStockResponse for displaying stock quantities in list.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Alembic migration</name>
  <files>alembic/versions/002_products_stocks.py</files>
  <action>
Create Alembic migration file following the pattern from 001_initial.py:

**Revision ID:** '002'
**down_revision:** '001'

**upgrade():**
1. Create 'products' table:
   - id: UUID primary key
   - barcode: String(100), unique, NOT NULL
   - gtin: String(14), unique, NOT NULL
   - seller_sku: String(100), nullable
   - size: String(50), nullable
   - brand: String(255), nullable
   - color: String(100), nullable
   - is_deleted: Boolean, default=False, NOT NULL
   - created_at, updated_at: DateTime with timezone
   - Create index on barcode, gtin, is_deleted

2. Create 'stocks' table:
   - id: UUID primary key
   - product_id: UUID, ForeignKey('products.id'), unique constraint
   - quantity: Integer, default=0, NOT NULL
   - created_at, updated_at: DateTime with timezone

3. Create 'defect_stocks' table:
   - Same structure as stocks but for defect quantities

**downgrade():**
- Drop tables in reverse order: defect_stocks, stocks, products
- Drop indexes

Follow exact syntax from 001_initial.py for consistency.
  </action>
  <verify>
grep -l "revision.*002" alembic/versions/002_products_stocks.py && \
grep -E "create_table.*products|create_table.*stocks|create_table.*defect_stocks" alembic/versions/002_products_stocks.py
  </verify>
  <done>
Migration 002 creates products, stocks, and defect_stocks tables with proper constraints and indexes.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All model files exist and follow SQLAlchemy 2.0 Mapped[] patterns
2. Schemas include ProductWithStockResponse for stock display
3. Migration creates all three tables with proper constraints
4. Models export correctly from __init__.py
</verification>

<success_criteria>
- [ ] Product model with barcode (unique), gtin (unique), seller_sku, size, brand, color, is_deleted
- [ ] Stock model with product_id foreign key (unique constraint)
- [ ] DefectStock model with product_id foreign key (unique constraint)
- [ ] ProductWithStockResponse schema includes stock_quantity and defect_quantity
- [ ] Migration 002 ready to create all tables
</success_criteria>

<output>
After completion, create `.planning/phases/02-master-data-warehouses/02-01-SUMMARY.md`
</output>
