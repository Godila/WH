---
phase: 06-infrastructure-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile.frontend
  - nginx.conf
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Frontend container serves React app via nginx"
    - "nginx proxies /api requests to backend service"
    - "nginx handles SPA routing with try_files"
    - "nginx provides /health endpoint for healthchecks"
    - ".env.example documents required environment variables"
  artifacts:
    - path: "Dockerfile.frontend"
      provides: "Frontend container image"
      contains: "FROM node:20-alpine"
      min_lines: 20
    - path: "nginx.conf"
      provides: "nginx reverse proxy configuration"
      contains: "proxy_pass http://backend:8000"
      min_lines: 25
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "SECRET_KEY"
  key_links:
    - from: "Dockerfile.frontend"
      to: "nginx.conf"
      via: "COPY"
      pattern: "COPY nginx.conf"
    - from: "nginx.conf"
      to: "backend:8000"
      via: "proxy_pass"
      pattern: "proxy_pass http://backend:8000"
    - from: "nginx.conf"
      to: "/usr/share/nginx/html"
      via: "root"
      pattern: "root /usr/share/nginx/html"
---

<objective>
Create Docker image for the React frontend with nginx reverse proxy.

Purpose: Enable containerized frontend deployment with API proxying and SPA routing.
Output: Dockerfile.frontend, nginx.conf, .env.example
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-infrastructure-deployment/06-CONTEXT.md
@.planning/phases/06-infrastructure-deployment/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create nginx.conf for React SPA</name>
  <files>nginx.conf</files>
  <action>
    Create nginx.conf in project root with the following configuration:
    
    ```nginx
    server {
        listen 80;
        server_name localhost;

        # Serve static files from React build
        location / {
            root /usr/share/nginx/html;
            index index.html;
            
            # SPA routing - try files first, fall back to index.html
            try_files $uri $uri/ /index.html;
        }

        # Proxy API requests to backend service
        location /api {
            proxy_pass http://backend:8000;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Healthcheck endpoint for Docker
        location /health {
            access_log off;
            return 200 "ok";
            add_header Content-Type text/plain;
        }
    }
    ```
    
    Key points:
    - `try_files` handles React Router (SPA) - refreshes on /movements won't return 404
    - `/api` proxy to backend using Docker service name
    - `/health` endpoint for container healthchecks
    - No hardcoded localhost - uses 'backend' service name
  </action>
  <verify>
    ```bash
    cat nginx.conf | grep -E "try_files|proxy_pass.*backend|location /health"
    ```
  </verify>
  <done>nginx.conf exists with SPA routing (try_files), API proxy to backend:8000, and /health endpoint</done>
</task>

<task type="auto">
  <name>Create Dockerfile.frontend for React + nginx</name>
  <files>Dockerfile.frontend</files>
  <action>
    Create Dockerfile.frontend in project root with multi-stage build:
    
    ```dockerfile
    # Stage 1: Build React application
    FROM node:20-alpine AS builder

    WORKDIR /app

    # Copy package files first for caching
    COPY frontend/package*.json ./
    RUN npm ci

    # Copy source and build
    COPY frontend/ ./
    RUN npm run build

    # Stage 2: Production image with nginx
    FROM nginx:alpine

    # Install curl for healthcheck
    RUN apk add --no-cache curl

    # Copy built assets from builder stage
    COPY --from=builder /app/dist /usr/share/nginx/html

    # Copy nginx configuration
    COPY nginx.conf /etc/nginx/conf.d/default.conf

    EXPOSE 80

    CMD ["nginx", "-g", "daemon off;"]
    ```
    
    Key points:
    - Multi-stage build keeps final image small
    - node:20-alpine for build, nginx:alpine for serving
    - npm ci for clean install
    - nginx.conf copied to conf.d/default.conf (overrides default config)
    - curl installed for healthcheck
  </action>
  <verify>
    ```bash
    cat Dockerfile.frontend | grep -E "FROM node:20|FROM nginx:alpine|COPY nginx.conf|npm run build"
    ```
  </verify>
  <done>Dockerfile.frontend exists with multi-stage build, nginx alpine, and nginx.conf copy</done>
</task>

<task type="auto">
  <name>Create .env.example</name>
  <files>.env.example</files>
  <action>
    Create .env.example in project root with environment variable templates:
    
    ```env
    # Database Configuration
    # In Docker, use service name 'postgres' instead of 'localhost'
    DATABASE_URL=postgresql+asyncpg://postgres:postgres@postgres:5432/wms
    DB_USER=postgres
    DB_PASSWORD=postgres

    # Security
    # IMPORTANT: Change this in production!
    SECRET_KEY=your-super-secret-key-change-in-production

    # Application
    DEBUG=false
    ACCESS_TOKEN_EXPIRE_MINUTES=30
    ```
    
    Notes:
    - DATABASE_URL uses 'postgres' as hostname (Docker service name)
    - SECRET_KEY should be changed for production
    - This file is a template - actual .env should NOT be committed
  </action>
  <verify>
    ```bash
    cat .env.example | grep -E "DATABASE_URL|SECRET_KEY|postgres"
    ```
  </verify>
  <done>.env.example exists with DATABASE_URL, DB_USER, DB_PASSWORD, SECRET_KEY, DEBUG</done>
</task>

</tasks>

<verification>
```bash
# Verify all files exist
ls -la Dockerfile.frontend nginx.conf .env.example

# Verify nginx has correct proxy target
grep "proxy_pass http://backend:8000" nginx.conf

# Verify Dockerfile copies nginx.conf
grep "COPY nginx.conf" Dockerfile.frontend
```
</verification>

<success_criteria>
- nginx.conf has try_files for SPA, proxy_pass to backend:8000, /health endpoint
- Dockerfile.frontend has multi-stage build with nginx:alpine
- .env.example documents DATABASE_URL with postgres hostname
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-deployment/06-02-SUMMARY.md`
</output>
