---
phase: 03-stock-core-operations
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/services/movement.py
  - app/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "RECEIPT operation increases Stock.quantity"
    - "RECEIPT_DEFECT operation increases DefectStock.quantity"
    - "SHIPMENT_RC decreases Stock.quantity and fails if insufficient stock"
    - "RETURN_PICKUP increases Stock.quantity (requires source_id)"
    - "RETURN_DEFECT increases DefectStock.quantity (requires source_id)"
    - "SELF_PURCHASE increases Stock.quantity (requires source_id)"
    - "WRITE_OFF decreases Stock and increases DefectStock atomically"
    - "RESTORATION decreases DefectStock and increases Stock atomically"
    - "UTILIZATION decreases DefectStock and fails if insufficient defect stock"
    - "All operations are atomic - either all updates happen or none"
    - "All operations create StockMovement audit log entry"
  artifacts:
    - path: "app/services/movement.py"
      provides: "MovementService with 9 operation handlers"
      min_lines: 150
      exports: ["MovementService"]
  key_links:
    - from: "MovementService.execute_movement"
      to: "Stock model"
      via: "UPDATE with quantity check"
      pattern: "UPDATE.*stocks.*WHERE.*quantity"
    - from: "MovementService.execute_movement"
      to: "StockMovement model"
      via: "audit log insert"
      pattern: "StockMovement("
---

<objective>
Implement the MovementService with all 9 stock operations.

Purpose: Core business logic for stock movements with validation, atomic updates, and audit logging.
Output: MovementService class that handles all operation types safely.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan artifacts
@app/models/stock_movement.py
@app/schemas/movement.py

# Existing models
@app/models/stock.py
@app/models/defect_stock.py
@app/models/product.py

# Service pattern reference
@app/services/auth.py
</context>

<tasks>

<task type="auto">
  <name>Create MovementService with 9 operation handlers</name>
  <files>app/services/movement.py, app/services/__init__.py</files>
  <action>
Create `app/services/movement.py` with MovementService class:

```python
class MovementService:
    """Service for executing stock movement operations atomically."""
    
    @staticmethod
    async def execute_movement(
        db: AsyncSession,
        data: MovementCreate,
        user_id: str
    ) -> StockMovement:
        """
        Execute a stock movement operation atomically.
        
        1. Validates product exists and is not deleted
        2. Validates conditional fields (source_id, distribution_center_id)
        3. Executes stock updates based on operation type
        4. Creates audit log entry
        5. All in a single transaction (atomic)
        
        Raises:
            HTTPException 400: Validation error
            HTTPException 404: Product not found
        """
```

**Implementation details:**

1. **Validation helper** `_validate_product_exists()`:
   - Query Product by product_id
   - Ensure product exists and is_deleted=False
   - Return product or raise 404

2. **Stock update methods** using raw SQL for TOCTOU safety:
   ```python
   # Example: Atomic stock decrease with validation
   result = await db.execute(
       text("UPDATE stocks SET quantity = quantity - :qty 
             WHERE product_id = :pid AND quantity >= :qty
             RETURNING quantity"),
       {"qty": quantity, "pid": product_id}
   )
   if not result.fetchone():
       raise HTTPException(400, "Insufficient stock")
   ```

3. **Operation handlers** (inside execute_movement switch):
   
   - **RECEIPT**: `UPDATE stocks SET quantity = quantity + :qty WHERE product_id = :pid`
   
   - **RECEIPT_DEFECT**: `UPDATE defect_stocks SET quantity = quantity + :qty WHERE product_id = :pid`
   
   - **SHIPMENT_RC**: Atomic decrease with validation:
     ```sql
     UPDATE stocks SET quantity = quantity - :qty 
     WHERE product_id = :pid AND quantity >= :qty
     ```
     If no rows updated → raise 400 "Insufficient stock for shipment"
   
   - **RETURN_PICKUP**: Increase stocks (source_id already validated in schema)
   
   - **RETURN_DEFECT**: Increase defect_stocks (source_id already validated in schema)
   
   - **SELF_PURCHASE**: Increase stocks (source_id already validated in schema)
   
   - **WRITE_OFF**: Two atomic operations in same transaction:
     ```sql
     UPDATE stocks SET quantity = quantity - :qty 
     WHERE product_id = :pid AND quantity >= :qty
     UPDATE defect_stocks SET quantity = quantity + :qty 
     WHERE product_id = :pid
     ```
     If first fails → raise 400 "Insufficient stock for write-off"
   
   - **RESTORATION**: Two atomic operations:
     ```sql
     UPDATE defect_stocks SET quantity = quantity - :qty 
     WHERE product_id = :pid AND quantity >= :qty
     UPDATE stocks SET quantity = quantity + :qty 
     WHERE product_id = :pid
     ```
     If first fails → raise 400 "Insufficient defect stock for restoration"
   
   - **UTILIZATION**: Atomic decrease with validation:
     ```sql
     UPDATE defect_stocks SET quantity = quantity - :qty 
     WHERE product_id = :pid AND quantity >= :qty
     ```
     If no rows updated → raise 400 "Insufficient defect stock for utilization"

4. **Audit logging**: After successful stock update, create StockMovement record:
   ```python
   movement = StockMovement(
       operation_type=data.operation_type,
       product_id=data.product_id,
       quantity=data.quantity,
       source_id=data.source_id,
       distribution_center_id=data.distribution_center_id,
       user_id=user_id,
       notes=data.notes
   )
   db.add(movement)
   ```

5. **Transaction handling**: All operations use existing db session, commit happens in API layer after service returns

6. **Update `app/services/__init__.py`** to export MovementService

**CRITICAL**: Use `text()` from sqlalchemy for raw SQL updates to ensure atomicity and prevent TOCTOU race conditions. DO NOT use ORM updates (they don't support WHERE ... AND quantity >= :qty).

**Error messages** (in Russian for consistency):
- "Недостаточно товара для отгрузки"
- "Недостаточно товара для списания в брак"
- "Недостаточно брака для восстановления"
- "Недостаточно брака для утилизации"
</action>
  <verify>
grep -q "class MovementService" app/services/movement.py && \
grep -q "execute_movement" app/services/movement.py && \
grep -q "RECEIPT" app/services/movement.py && \
grep -q "SHIPMENT_RC" app/services/movement.py && \
grep -q "WRITE_OFF" app/services/movement.py && \
grep -q "quantity >=" app/services/movement.py
</verify>
  <done>MovementService exists with all 9 operations, atomic updates with TOCTOU protection, and audit logging</done>
</task>

</tasks>

<verification>
1. MovementService class exists with execute_movement method
2. All 9 operation types handled in switch/if-else
3. Stock decreases use WHERE quantity >= :qty for TOCTOU safety
4. WRITE_OFF and RESTORATION update both tables atomically
5. StockMovement audit record created for all operations
6. Error handling returns 400 with descriptive messages
7. Run: `python -c "from app.services.movement import MovementService; print('OK')"`
</verification>

<success_criteria>
- All 9 operations implemented with correct stock effects
- Atomic updates prevent negative stock (TOCTOU-safe)
- WRITE_OFF/RESTORATION are atomic (both tables or neither)
- All operations create StockMovement audit entries
- Clear Russian error messages for insufficient stock
</success_criteria>

<output>
After completion, create `.planning/phases/03-stock-core-operations/03-02-SUMMARY.md`
</output>
