---
phase: 03-stock-core-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/stock_movement.py
  - app/models/__init__.py
  - app/schemas/movement.py
  - alembic/versions/003_stock_movements.py
autonomous: true

must_haves:
  truths:
    - "StockMovement model stores operation type, quantity, product, optional source/dc"
    - "OperationType enum defines all 9 operation types"
    - "Migration creates stock_movements table with proper indexes"
    - "Schemas define request/response shapes for movement operations"
  artifacts:
    - path: "app/models/stock_movement.py"
      provides: "StockMovement SQLAlchemy model"
      min_lines: 40
    - path: "app/schemas/movement.py"
      provides: "Movement Pydantic schemas"
      exports: ["MovementCreate", "MovementResponse", "MovementFilter", "MovementListResponse"]
    - path: "alembic/versions/003_stock_movements.py"
      provides: "Migration for stock_movements table"
      contains: "op.create_table"
  key_links:
    - from: "app/models/stock_movement.py"
      to: "app/models/product.py"
      via: "ForeignKey product_id"
      pattern: "ForeignKey.*products.id"
    - from: "app/models/stock_movement.py"
      to: "app/models/source.py"
      via: "Nullable ForeignKey source_id"
    - from: "app/models/stock_movement.py"
      to: "app/models/distribution_center.py"
      via: "Nullable ForeignKey distribution_center_id"
---

<objective>
Create the data layer for stock movement operations.

Purpose: Define the StockMovement model, OperationType enum, and schemas needed to record all stock operations in the journal.
Output: Model, schemas, and migration ready for service layer implementation.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing models to reference
@app/models/product.py
@app/models/stock.py
@app/models/defect_stock.py
@app/models/source.py
@app/models/distribution_center.py
@app/models/user.py

# Existing schema pattern
@app/schemas/product.py
</context>

<tasks>

<task type="auto">
  <name>Create StockMovement model with OperationType enum</name>
  <files>app/models/stock_movement.py, app/models/__init__.py</files>
  <action>
Create `app/models/stock_movement.py` with:

1. **OperationType enum** (use Python Enum, not SQLAlchemy Enum for clarity):
   - RECEIPT = "receipt" - приемка годного
   - RECEIPT_DEFECT = "receipt_defect" - приемка брака
   - SHIPMENT_RC = "shipment_rc" - отгрузка в РЦ
   - RETURN_PICKUP = "return_pickup" - возврат годного с ПВЗ
   - RETURN_DEFECT = "return_defect" - возврат брака
   - SELF_PURCHASE = "self_purchase" - самовыкуп
   - WRITE_OFF = "write_off" - списание в брак
   - RESTORATION = "restoration" - восстановление
   - UTILIZATION = "utilization" - утилизация

2. **StockMovement model** extending Base, UUIDMixin, TimestampMixin:
   - operation_type: Mapped[str] - store enum value as string
   - product_id: Mapped[str] - FK to products.id, required, indexed
   - quantity: Mapped[int] - required, positive integer
   - source_id: Mapped[Optional[str]] - nullable FK to sources.id
   - distribution_center_id: Mapped[Optional[str]] - nullable FK to distribution_centers.id
   - user_id: Mapped[str] - FK to users.id, who performed operation
   - notes: Mapped[Optional[str]] - Text field for comments

3. **Relationships**:
   - product: relationship to Product
   - source: relationship to Source (nullable)
   - distribution_center: relationship to DistributionCenter (nullable)
   - user: relationship to User

4. **Update `app/models/__init__.py`** to export StockMovement and OperationType

Pattern reference: Use same style as existing models in app/models/product.py
</action>
  <verify>
grep -q "class StockMovement" app/models/stock_movement.py && \
grep -q "class OperationType" app/models/stock_movement.py && \
grep -q "RECEIPT" app/models/stock_movement.py && \
grep -q "stock_movement" app/models/__init__.py
</verify>
  <done>StockMovement model exists with all 9 operation types in enum, model has all required fields and relationships</done>
</task>

<task type="auto">
  <name>Create Movement Pydantic schemas</name>
  <files>app/schemas/movement.py</files>
  <action>
Create `app/schemas/movement.py` with:

1. **MovementBase** (Pydantic BaseModel):
   - product_id: UUID
   - operation_type: str (will validate against OperationType values)
   - quantity: int (ge=1, description="Quantity must be positive")
   - source_id: Optional[UUID] = None
   - distribution_center_id: Optional[UUID] = None
   - notes: Optional[str] = None

2. **MovementCreate** (extends MovementBase):
   - Add model_validator to enforce conditional fields:
     - If operation_type in [RETURN_PICKUP, RETURN_DEFECT, SELF_PURCHASE]: source_id is required
     - If operation_type == SHIPMENT_RC: distribution_center_id is required
   - Use Pydantic v2 @model_validator mode='after' pattern

3. **MovementResponse** (extends MovementBase):
   - id: UUID
   - user_id: UUID
   - created_at: datetime
   - Include product_barcode, product_gtin for display (via model_dump with computed fields or nested)

4. **MovementFilter** (BaseModel for query params):
   - operation_type: Optional[str] = None
   - product_id: Optional[UUID] = None
   - date_from: Optional[datetime] = None
   - date_to: Optional[datetime] = None

5. **MovementListResponse** (paginated):
   - items: list[MovementResponse]
   - total: int
   - page: int
   - page_size: int
   - pages: int

Reference pattern from app/schemas/product.py
</action>
  <verify>
grep -q "class MovementCreate" app/schemas/movement.py && \
grep -q "class MovementResponse" app/schemas/movement.py && \
grep -q "class MovementFilter" app/schemas/movement.py && \
grep -q "class MovementListResponse" app/schemas/movement.py
</verify>
  <done>Movement schemas exist with conditional field validation for source_id and distribution_center_id</done>
</task>

<task type="auto">
  <name>Create Alembic migration for stock_movements table</name>
  <files>alembic/versions/003_stock_movements.py</files>
  <action>
Create migration file `alembic/versions/003_stock_movements.py`:

1. **upgrade()**:
   - Create stock_movements table with columns:
     - id: UUID primary key
     - operation_type: VARCHAR(50) NOT NULL
     - product_id: UUID NOT NULL
     - quantity: INTEGER NOT NULL
     - source_id: UUID NULL
     - distribution_center_id: UUID NULL
     - user_id: UUID NOT NULL
     - notes: TEXT NULL
     - created_at: TIMESTAMP WITH TIME ZONE
     - updated_at: TIMESTAMP WITH TIME ZONE
   
   - Foreign keys:
     - product_id -> products.id ON DELETE CASCADE
     - source_id -> sources.id ON DELETE SET NULL
     - distribution_center_id -> distribution_centers.id ON DELETE SET NULL
     - user_id -> users.id ON DELETE CASCADE

   - Indexes (for filtering performance):
     - ix_stock_movements_product_id
     - ix_stock_movements_operation_type
     - ix_stock_movements_created_at (for date range queries)
     - ix_stock_movements_user_id

2. **downgrade()**:
   - Drop stock_movements table

Use existing migrations as pattern reference (002_products_stocks.py style)
</action>
  <verify>
test -f alembic/versions/003_stock_movements.py && \
grep -q "op.create_table.*stock_movements" alembic/versions/003_stock_movements.py && \
grep -q "op.drop_table" alembic/versions/003_stock_movements.py
</verify>
  <done>Migration file exists with table creation, foreign keys, and indexes for filtering</done>
</task>

</tasks>

<verification>
1. StockMovement model compiles without errors
2. OperationType enum contains all 9 operation types
3. Schemas validate conditional fields correctly
4. Migration has proper indexes for journal filtering
5. Run: `alembic upgrade head` should succeed (if db available)
</verification>

<success_criteria>
- StockMovement model exists with all fields from requirements
- OperationType enum defines all 9 operation types
- MovementCreate validates conditional fields (source_id for RETURN_*, SELF_PURCHASE; dc_id for SHIPMENT_RC)
- Migration creates table with indexes on product_id, operation_type, created_at
</success_criteria>

<output>
After completion, create `.planning/phases/03-stock-core-operations/03-01-SUMMARY.md`
</output>
