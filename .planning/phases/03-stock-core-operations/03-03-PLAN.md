---
phase: 03-stock-core-operations
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - app/api/stock.py
  - app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/stock/movements creates a movement and updates stock"
    - "GET /api/stock/movements returns paginated journal with filters"
    - "GET /api/stock/summary returns total_products, total_stock, total_defect"
    - "Journal can be filtered by operation_type, product_id, date_from, date_to"
    - "Journal sorted by created_at DESC (newest first)"
    - "Attempt to ship more than available returns 400 error"
    - "Attempt to utilize more defect than available returns 400 error"
  artifacts:
    - path: "app/api/stock.py"
      provides: "Stock operations API endpoints"
      min_lines: 100
      exports: ["router"]
  key_links:
    - from: "POST /api/stock/movements"
      to: "MovementService.execute_movement"
      via: "service call"
      pattern: "MovementService.execute"
    - from: "GET /api/stock/movements"
      to: "StockMovement model"
      via: "filtered query"
      pattern: "select.*StockMovement"
    - from: "GET /api/stock/summary"
      to: "Stock + DefectStock models"
      via: "aggregation query"
      pattern: "func.count|func.sum"
---

<objective>
Create the Stock API endpoints for movements and summary.

Purpose: Expose stock operations via REST API with proper authentication and filtering.
Output: Working API for stock movements journal and summary report.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan artifacts
@app/services/movement.py
@app/models/stock_movement.py
@app/schemas/movement.py

# Existing models
@app/models/stock.py
@app/models/defect_stock.py
@app/models/product.py

# API pattern reference
@app/api/products.py
@app/api/deps.py
</context>

<tasks>

<task type="auto">
  <name>Create POST /api/stock/movements endpoint</name>
  <files>app/api/stock.py</files>
  <action>
Create `app/api/stock.py` with:

```python
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from app.database import get_db
from app.models.user import User
from app.schemas.movement import (
    MovementCreate, MovementResponse, 
    MovementFilter, MovementListResponse
)
from app.services.movement import MovementService
from app.api.deps import get_current_user

router = APIRouter(prefix="/stock", tags=["stock"])


@router.post("/movements", response_model=MovementResponse, 
             status_code=status.HTTP_201_CREATED)
async def create_movement(
    data: MovementCreate,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> MovementResponse:
    """
    Execute a stock movement operation.
    
    - Validates product exists
    - Validates conditional fields (source_id, distribution_center_id)
    - Updates stock atomically
    - Creates audit log entry
    
    Returns 400 if insufficient stock for the operation.
    """
    movement = await MovementService.execute_movement(
        db=db,
        data=data,
        user_id=str(current_user.id)
    )
    await db.commit()
    await db.refresh(movement)
    
    # Load relationships for response
    await db.refresh(movement, ["product"])
    
    return MovementResponse(
        id=movement.id,
        operation_type=movement.operation_type,
        product_id=movement.product_id,
        quantity=movement.quantity,
        source_id=movement.source_id,
        distribution_center_id=movement.distribution_center_id,
        user_id=movement.user_id,
        notes=movement.notes,
        created_at=movement.created_at,
        product_barcode=movement.product.barcode,
        product_gtin=movement.product.gtin,
    )
```

The endpoint:
1. Accepts MovementCreate validated by Pydantic
2. Calls MovementService.execute_movement()
3. Commits transaction on success
4. Returns MovementResponse with product details
</action>
  <verify>
grep -q "router = APIRouter" app/api/stock.py && \
grep -q 'post.*movements' app/api/stock.py && \
grep -q "MovementService.execute" app/api/stock.py
</verify>
  <done>POST /api/stock/movements endpoint exists and calls MovementService</done>
</task>

<task type="auto">
  <name>Create GET /api/stock/movements journal endpoint</name>
  <files>app/api/stock.py</files>
  <action>
Add to `app/api/stock.py`:

```python
@router.get("/movements", response_model=MovementListResponse)
async def list_movements(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    operation_type: str | None = Query(None, description="Filter by operation type"),
    product_id: UUID | None = Query(None, description="Filter by product"),
    date_from: datetime | None = Query(None, description="Filter from date"),
    date_to: datetime | None = Query(None, description="Filter to date"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> MovementListResponse:
    """
    List stock movement journal with filtering and pagination.
    
    - Filter by operation_type, product_id, date range
    - Sorted by created_at DESC (newest first)
    - Includes product barcode and GTIN for display
    """
```

Implementation:
1. **Base query**: `select(StockMovement).options(selectinload(StockMovement.product))`
2. **Apply filters**:
   - `operation_type`: `.where(StockMovement.operation_type == operation_type)`
   - `product_id`: `.where(StockMovement.product_id == product_id)`
   - `date_from`: `.where(StockMovement.created_at >= date_from)`
   - `date_to`: `.where(StockMovement.created_at <= date_to)`
3. **Count total**: Use func.count() on filtered query
4. **Order**: `.order_by(StockMovement.created_at.desc())`
5. **Paginate**: `.offset((page - 1) * page_size).limit(page_size)`
6. **Return MovementListResponse** with items including product_barcode, product_gtin

Reference pagination pattern from app/api/products.py
</action>
  <verify>
grep -q 'get.*movements' app/api/stock.py && \
grep -q "operation_type" app/api/stock.py && \
grep -q "date_from" app/api/stock.py && \
grep -q "date_to" app/api/stock.py && \
grep -q "MovementListResponse" app/api/stock.py
</verify>
  <done>GET /api/stock/movements returns paginated journal with all filter params</done>
</task>

<task type="auto">
  <name>Create GET /api/stock/summary endpoint</name>
  <files>app/api/stock.py, app/main.py</files>
  <action>
Add to `app/api/stock.py`:

```python
@router.get("/summary")
async def get_stock_summary(
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
) -> dict:
    """
    Get stock summary statistics.
    
    Returns:
        - total_products: Count of non-deleted products
        - total_stock: Sum of all Stock quantities
        - total_defect: Sum of all DefectStock quantities
    """
```

Implementation:
```python
# Count non-deleted products
product_count = await db.execute(
    select(func.count()).select_from(Product).where(Product.is_deleted == False)
)
total_products = product_count.scalar() or 0

# Sum all stock quantities
stock_sum = await db.execute(
    select(func.coalesce(func.sum(Stock.quantity), 0))
)
total_stock = stock_sum.scalar() or 0

# Sum all defect quantities
defect_sum = await db.execute(
    select(func.coalesce(func.sum(DefectStock.quantity), 0))
)
total_defect = defect_sum.scalar() or 0

return {
    "total_products": total_products,
    "total_stock": total_stock,
    "total_defect": total_defect,
}
```

**Update `app/main.py`** to include the stock router:
```python
from app.api.stock import router as stock_router
# ...
app.include_router(stock_router, prefix="/api")
```
</action>
  <verify>
grep -q 'get.*summary' app/api/stock.py && \
grep -q "total_products" app/api/stock.py && \
grep -q "total_stock" app/api/stock.py && \
grep -q "total_defect" app/api/stock.py && \
grep -q "from app.api.stock" app/main.py
</verify>
  <done>GET /api/stock/summary returns aggregated statistics and router registered</done>
</task>

</tasks>

<verification>
1. POST /api/stock/movements creates movement and updates stock
2. GET /api/stock/movements returns paginated list with all filters working
3. GET /api/stock/summary returns correct totals
4. All endpoints require authentication (401 without token)
5. Router registered in main.py
6. Run: `curl -X GET http://localhost:8000/api/stock/summary -H "Authorization: Bearer <token>"`
</verification>

<success_criteria>
- POST /api/stock/movements executes operations atomically
- GET /api/stock/movements supports filtering by type, product, date range
- Journal sorted by created_at DESC
- GET /api/stock/summary returns total_products, total_stock, total_defect
- All endpoints protected by JWT auth
</success_criteria>

<output>
After completion, create `.planning/phases/03-stock-core-operations/03-03-SUMMARY.md`
</output>
